<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Rx</title>
        <link rel="stylesheet" href="/assets/css/styles.css">
    </head>
    <body>
        <nav>
    
    <a href="/" >Home</a>
    
    <a href="/recent.html" >Blog</a>
    
    <a href="/about.html" >About</a>
    
</nav>

        <h1 id="리액티브-스프링-분산처리-시스템">리액티브 스프링 분산처리 시스템</h1>

<h2 id="index">Index</h2>
<ol>
  <li>왜 반응성이 필요한가?</li>
  <li>리액티브 시스템의 기본 원리(중요)</li>
  <li>리액티브 시스템 설계에 완벽하게 일치하는 비즈니스 사례</li>
  <li>리액티브 시스템에 좀 더 적합한 프로그래밍 기술</li>
  <li>스프링 프레임워크가 리액티브로 전환하는 이유</li>
</ol>

<h2 id="1-왜-리액티브인가">1. 왜 리액티브인가?</h2>
<ul>
  <li>시간당 평균 1,000명의 사용자가 방문한다고 가장
    <ul>
      <li>톰캣(Tomcat) 웹 서버 + 500개의 스래드 풀로 구성</li>
      <li>평균 응답 시간은 250 ms</li>
    </ul>
  </li>
  <li>초당 몇 명의 사용자 요철을 처리할 수 있는가? 그리고 이 A서버의 문제는 무엇인가?
1) 답: 2,000
2) 답: 확장성 제한, 단일 서버 확장성 제한 예) 로스트 아크</li>
</ul>

<p>해결책</p>
<ol>
  <li>탄력성(elasticity)
    <ul>
      <li>작업 부하에서 응답성을 유지하는 능력</li>
      <li>시스템 처리량이 자동으로 증가해야 하고 수요가 감소하면 자동으로 감소해야함</li>
    </ul>
  </li>
  <li>문제 해결을 위한 가장 흔한 방법
    <ul>
      <li>수평적/ 수직적 확장</li>
    </ul>
  </li>
  <li>암달의 법칙(Amdahl’s Law)/ Gunther의 보편적 확장성 모델(Universal Scalability Model)</li>
</ol>

<ul>
  <li>수평적 확장 시 성능이 비약적으로 늘지 않음 &gt; 수직적 확장(메모리 증설) * 서버를 꺼야함, 서버 세팅을 다시해야 함</li>
</ul>

<p>베어메탈(서버 컴퓨터)</p>

<p>2010 AWS 등장 이후-&gt;  수평/ 수직 확장</p>

<ul>
  <li>그러나 장애 발생과 무관하게 응답성을 유지하는 능력을 갖추지 않고 확장 가능한 분산 시스템을 구축하는 것은 어려움</li>
  <li>해결방법
    <ul>
      <li>시스템의 기능 요소를 격리해 모든 내부 장애를 격리하고 독립성을 확보함으로써 달성할 수 있음</li>
    </ul>
  </li>
  <li>탄력성과 복원력이 밀접하게 결합돼 있으며, 이 두 가지를 모두 사용할 때만 시스템의 진정한 응답성을 달성할 수 있다는 것</li>
</ul>

<p>1.2  메세지 기반 통신</p>
<ol>
  <li>문제점</li>
</ol>

<p>컴퓨터 구조, 네트워크, 운영체제
블럭킹, 논블럭킹, 동기, 비동기
1) 블럭킹 + 동기 : 파일 입출력
2) 논블럭킹 + 비동기 : stream, NIO2
3) 블럭킹 + 비동기 : ? 가산점
4) 논블럭킹 + 동기 : ??????? 아직 모름</p>

<h2 id="리액티브-시스템의-기본-원리">리액티브 시스템의 기본 원리</h2>
<p>[[https://www.reactivemanifesto.org/ko]]
가치 : 응답성
매개체 : 탄력성(시스템이 얼마 만큰 load에 대해서 응답), 복원력(시스템이 무너졌다가 살아나는 능력)
표현 방식 : 메시지 기반(MPI)
정리 : <strong>메시지 기반을 중심으로 탄력성과 복원력을 높여 응답성을 보장</strong>
아파치 카프카(생산자, 소비자)</p>

<p>카프카(메시지 기반), 스프링, 서버(클라우드 &gt; 탄력성과 복원력), 리액트(응답성)
부산 센텀 -&gt; AWS 강의</p>

<p>자바의 까다로운 부분</p>
<ol>
  <li>파일 입출력</li>
  <li>제네릭</li>
  <li>콜렉션</li>
  <li>쓰레드</li>
  <li>날짜</li>
</ol>

<p>리액티브 시스템 설계에 완벽하게 일치하는 비즈니스 사례</p>
<ul>
  <li>[[https://microservices.io/patterns/]]</li>
  <li>모던 마이크로서피스 패턴을 예로 든 웹 스토어를 개선</li>
  <li>위치 투명성을 위해 API 게이트 패턴을 서용</li>
  <li>위와 비슷한 사례로 ‘애널리틱스’ 분야를 들 수 있음</li>
</ul>

<p>모든 객체는 섬이다. (Solid)
어떠한 객체도 섬이 아니다. (상속, 인터페이스) -&gt; 메세지
클린 아키택쳐</p>

<p>스프링 배치 카프카</p>

<p>Redux : 상태 메시지 관리 머신
메세지는 메세지 큐</p>

<p>리액티브 시스템에 좀 더 적합한 프로그래밍 기술</p>
<ul>
  <li>복원성 확복
    <ul>
      <li>배압 지원을 활성화해야함</li>
    </ul>
  </li>
  <li>메시지 기반</li>
  <li>메시지 브로커가 필요함 &gt; 큐 프로그램 ex) 카프카 zeroMQ, rabbitmq</li>
  <li>실제 환경에서는 데이터 스트림이 일괄 처리로 데이터베이스</li>
</ul>

<p>도서 카프카, 데이터 플랫폼의 최강자 (공용준)</p>

<p>스프링 프레임 워크가 리액티브로 전환하는 이유</p>
<ul>
  <li>JVM 세계에서 리액티브 시스템을 구축하는데 쓰이는 가장 널리 알려진 프레임워크는 Akka 및 Vert.x</li>
  <li>스프링 클라우드
    <ul>
      <li>스프링 클라우드 프레임워크는 몇 가지 문제점을 해결하고 분산 시스템 구축을 단순화하는 기반 프로젝트</li>
    </ul>
  </li>
</ul>

<ol>
  <li>명령 -&gt; 동기 문제(블로킹) -&gt; 콜백 함수로 전달</li>
  <li>콜백 -&gt;  가장 큰 문제점 -&gt; hell 가독성 저하 시스템 부하</li>
  <li>쓰레드 -&gt; 시스템 부하/ 관리가 힘듦 -&gt; Future</li>
  <li>Future를 사용해서 결과값 반환을 지연 JDK6 version</li>
  <li>Promise를 CompletionStage와 CompletableFuture 이용해 구현  <code class="language-plaintext highlighter-rouge">.then</code>  JDK8 -&gt; 배압 X</li>
  <li><strong>RxJava</strong></li>
</ol>

<p>메시지 기반은 있다고 가정
리액티브 프로그래밍 핵심</p>
<ul>
  <li>비동기</li>
  <li>메시지</li>
</ul>

<p>[[https://sigmadream.tistory.com/95]]</p>


    </body>
</html>
