<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Reactjs</title>
        <link rel="stylesheet" href="/assets/css/styles.css">
    </head>
    <body>
        <nav>
    
    <a href="/" >Home</a>
    
    <a href="/recent.html" >Blog</a>
    
    <a href="/about.html" >About</a>
    
</nav>

        <h1 id="reactjs">ReactJS</h1>

<h2 id="1-도입">1. 도입</h2>
<ul>
  <li>UI를 효과적으로 구축하기 위해 사용하는 자바스크립트 기반의 프론트엔드 라이브러리</li>
  <li>선행 과정 JavaScript</li>
  <li>FACEBOOK 관리하는 OPENSOURCE 라이브러리</li>
  <li>MIT 라이센스를 따른다.</li>
</ul>

<h2 id="2-특징">2. 특징</h2>
<ul>
  <li>선언적(Declarative) : 대화형 UI를 작성하기에 유리함. 데이터가 변경되었을 때, 효율적으로 렌더링을 수행할 수 있도록 함</li>
  <li>컴포넌트 기반(Component-Based) : 캡슐화된 컴포넌트가 상태를 관리하고 UI를 효과적으로 구성할 수 있다.</li>
  <li>한 번 배워서 어디에서나 사용(Learn Once, Write Anywhere) : 코드의 재사용 용이</li>
</ul>

<h2 id="3-문서">3. 문서</h2>
<p>https://reactjs.org/docs/getting-started.html</p>

<p><strong>웹에서 실행하기</strong></p>
<blockquote>
  <p>https://reactjs.org/redirect-to-codepen/hello-world</p>
</blockquote>

<h2 id="4-장점">4. 장점</h2>
<ul>
  <li>뛰어난 성능을 가지고 있으며 클라이언트 렌더링 뿐만 아니라 서버 사이드 렌더링도 지원한다.</li>
  <li>Ajax 등과 같은 비동기 방식과 비교했을 때 검색 엔진 최적화 등에 있어서 유리하다.</li>
</ul>

<h2 id="5-props-vs-state">5. Props vs. State</h2>
<details>
  <h3 id="props-properties">Props (Properties)</h3>

  <ol>
    <li>컴포넌트에 값을 전달하는데 이용 (인자와 유사).</li>
    <li>props.defaultProps 를 이용해 기본 값을 정의할 수 있음.</li>
    <li>props의 값은 변경되어서는 안됨</li>
  </ol>

  <h3 id="starte">starte</h3>

  <ol>
    <li>컴포넌트에 대한 정보를 가짐</li>
    <li>값을 업데이트 할 수 있음 (ex: this.setState( {name: ‘foo’} );)</li>
    <li>컴포넌트에서 만들어짐</li>
  </ol>

  <h3 id="section">정리</h3>
  <ul>
    <li>props와 state 모두 컴포넌트와 관련된 정보를 나타내지만, 별도로 보관해야 함</li>
    <li>props에는 부모 컴포넌트가 설정한 정보가 들어 있지만 변경해선 안됨</li>
    <li>state에는 컴포넌트가 초기화, 변경 및 사용하는 ‘private’정보가 들어 있음</li>
  </ul>
</details>

<h2 id="6-react-lifecycle-및-api-호출">6. React LifeCycle 및 API 호출</h2>

<details>
  <h3 id="section-1">초기 구성</h3>
  <p><em>React 컴포넌트 객체가 DOM에 실제로 삽입되기 전까지의 과정(Mounting)</em></p>
  <ol>
    <li>constructor()</li>
    <li>componentWillMount()</li>
    <li>render()</li>
    <li>componentDidMount()</li>
  </ol>

  <p><strong>componentDidMount() 함수에서 API를 호출하는 것이 효과적임</strong></p>

  <h3 id="section-2">데이터 변경</h3>
  <p><em>객체를 렌더링 하기 위해 props 혹은 state를 사용</em></p>
  <ol>
    <li>shouldComponentUpdate() : 컴포넌트 업데이트를 수행할지 여부 확인</li>
    <li>compoentWillUpate()</li>
    <li>render() : 다시 화면이 구성</li>
    <li>componentDidUpdate() : 컴포넌트가 업데이트 됨</li>
  </ol>

  <h3 id="section-3">컴포넌트 해제</h3>
  <p><em>컴포넌트의 동작을 위해 사용됬었던 메소드들의 리소스를 제거, 성능 향상을 위해서 사용</em></p>
  <ul>
    <li>componentWillUnmount()</li>
  </ul>

  <p><strong>Server 없이 Web에서 JSON 데이터를 테스트 할 수 있는 사이트</strong></p>

  <p><a href="https://jsonplaceholder.typicode.com/">TEST_JSON_WEB_SERVER</a></p>

  <p>ex) API 호출
<code class="language-plaintext highlighter-rouge">index.html</code></p>
  <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"root"</span><span class="nt">&gt;&lt;/div&gt;</span>
</code></pre></div>  </div>

  <p><code class="language-plaintext highlighter-rouge">index.js</code></p>
  <pre><code class="language-JavaScript">class ApiExample extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      data: ''
    }
  }
  callApi = () =&gt; {
    fetch('https://jsonplaceholder.typicode.com/todos/1')
    .then(res =&gt; res.json())
    .then(json =&gt; {
      this.setState({
        data: json.title
      });
    })
  }
  componentDidMount() {
    this.callApi();
  }
  render() {
    return (
      &lt;h3&gt;
        {this.state.data? this.state.data : '데이터를 불러오는 중입니다.'}
      &lt;/h3&gt;
    );
  }
}

ReactDOM.render(&lt;ApiExample/&gt;, document.getElementById('root'));
</code></pre>
</details>

<h2 id="7-react-event-처리">7. React Event 처리</h2>

<details>
  <h3 id="section-4">정리</h3>
  <ol>
    <li>camelcase 사용 ex) <code class="language-plaintext highlighter-rouge">onClick</code></li>
    <li>JSX 문법 사용 ex) <code class="language-plaintext highlighter-rouge">{this.state.isToggleOn}</code></li>
    <li>JavaScript는 바인딩 처리가 기본설정으로 제공 되지 않음 (이벤트에 바인딩 처리가 필요)</li>
  </ol>

  <pre><code class="language-JavaScript">class EventHandling extends React.Component {
  constructor(props){
    super(props);
    this.state = {
      isToggleOn: true
    }
    this.handleClick = this.handleClick.bind(this);
  }
  handleClick() {
    this.setState({
        isToggleOn: !this.state.isToggleOn
    })
  }

  render() {
    return (
      &lt;button onClick={this.handleClick}&gt;
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      &lt;/button&gt;
    );
  }
}
ReactDOM.render(&lt;EventHandling/&gt;, document.getElementById('root'));
</code></pre>

  <h3 id="section-5">바인딩 처리 방법</h3>

  <h4 id="case1--">Case1.) 간단한 방법</h4>
  <pre><code class="language-JavaScript">class EventHandling extends React.Component {
  constructor(props){}
  handleClick = () =&gt; {
    this.setState({
        isToggleOn: !this.state.isToggleOn
    })
  }
  // 이하 생략
  }
}
</code></pre>

  <h4 id="case2--methodbindthis-">Case2.) 생성자에 <code class="language-plaintext highlighter-rouge">method.bind(this)</code> 추가</h4>
  <pre><code class="language-JavaScript">class EventHandling extends React.Component {
  constructor(props){
  this.handleClick = this.handleClick.bind(this);
  // 이하 생략
  }
}
</code></pre>

  <h4 id="case3-render--attr--methodbindthis-">Case3.) render 함수에 attr 부분 <code class="language-plaintext highlighter-rouge">method.bind(this)</code> 추가</h4>
  <pre><code class="language-JavaScript">class EventHandling extends React.Component {
  // 상단 생략
  render() {
    return (
      &lt;button onClick={this.handleClick.bind(this)}&gt;
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      &lt;/button&gt;
    );
  }
}
</code></pre>

</details>


    </body>
</html>
